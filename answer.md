> 1.1 Описать подход и ориентировочный алгоритм решения задачи. Клиенту необходимо запросить отчет в личном кабинете сервиса за последние 10 лет единым документом. Время формирования отчета не менее 5 минут. Как организовать процесс так, чтобы клиент не ждал эти 5 минут загрузки страницы и остался “доволен” результатом. Какие принципы и технологии обычно используются? Привести примеры.

Вариант 1:
- отправить запрос на формирование отчета в очередь, например, RabbitMQ
- сформировать отчет фоновым процессом
- отправить результат выполенения на email пользователя
    - если отчет большой, например, больше 5MB, то сохраняем на сервере, а на email отпавляем ссылку на скачаивание файла
    - иначе
        - прикрепляем файл с отчетом (.xlsx, .csv, etc)
        - или выводим в письме средставим HTML
        
Вариант 2:
- создать в БД таблицу отчетов 
    - ID
    - дата создания
    - статус (В очереди на обработку, Формируется, Сформирован, Ошибка)
    - пользователь
    - результат
        - ссылка на отчет, если требуется файл (можно не хранить, а формировать на основании ID)
        - json, если отчет представляет собой сгруппированные данные, которые нужно показать в интерфейсе или отправить на email
    - также можно добавить поля для отображения индикатора выполнения, например, если отчет не группирует данные и можно посчитать строки:
        - кол-во строк
        - текущая строка
- сохранить запрос на формирование отчета в базе данных
- сформировать отчет фоновым процессом
- показать ссылку на отчет пользователю
    - в интерфейсе
    - отправить email или SMS

В каждом варианте есть плюсы и минусы и выбор одного из вариантов зависит от поставленной задачи.

Второй вариант шире, т.к. можно хранить историю запросов, но в ряде случаев этот вариант может быть избыточным.

> 1.2 Имеется проблемная страница сайта с временем загрузки 10 секунд. Опишите ориентировочную последовательность действий, подход, сервисы, инструменты необходимые для решения проблемы в целом. Что наиболее приоритетно, что менее приоритетно? Задачу можно разбить по специалистам в условной команде, если требуется.

Я бы действовал в следующем порядке:

1. проверить количество и время выполнения запросов к БД (laravel: barryvdh/laravel-debugbar, yii2: yiisoft/yii2-debug)
    - избавиться от лишних запросов
    - оптимизировать запросы
    - применить кеширование данных
2. запустить инструменты разработчика в браузере (F12) и/или воспользоваться Google PageSpeed
    - Google PageSpeed скажет нам сразу где проблема
        - время ответа сервера
        - большие изображения
        - нет сжатия js и css
        - etc
    - то же самое только более детально можем посмотреть в инструментах разработчика в браузере
3. проходимся по возможным проблемам
    - если проблема в js и/или css, то отдаем задачу frontend-разработчику
    - если проблема в том что не включено сжатие, то отдаем задачу системному администратору, либо сами включаем в nginx, если вдруг системного администратора в команде нет
    - если страницу тормозит подключенный пиксель партнера, то сообщаем отделу маркетинга, что лучше бы этот пиксель отключить хотя бы на время и пообщаться с партнером о качестве его сервиса
    - если же проблема в backend и это не база данных
        - проверяем нагрузку на сервер
        - проверяем код, например, может быть проверка большого количества данных в цикле
        
> 1.3 В Yii2 каждый файл конфигурации хранится в двух видах. Зачем так сделано и как эти файлы ведут себя в git?

Файлы конфигурации делятся на общий и локальный, например:
- config/main.php
    - хранится в git
    - содержит общие настройки приложения для всех сред (prod, dev)
- config/main-local.php
    - не хранится в git (добавляется в .gitignore)
    - содержит настройки для конкретной среды

Это сделано для того, что бы не хранить в git, например, пароли для подключения к боевой базе данных, сервису отправки SMS сообщений, etc.
Также в локальном конфиге можно, например, подключать отладочные сервисы, например, DebugBar

Иначе эту проблему можно решить с помощью .env файлов
- .env.example
    - хранится в git
    - содержит общие настройки приложения для всех сред (prod, dev)
    - содержит переменные без знечений для конкретной среды
- .env
    - не хранится в git (добавляется в .gitignore)
    - содержит настройки для конкретной среды

> 1.4 Представим сервис, на котором постоянно происходит много регистраций по указанному email. Как наиболее корректно и достоверно проверять указанный email на валидность?

1. проверять на валидность на стороне клиента с помошью js, если введен не корректный email, то
    - показывать ошибку возле поля для ввода
    - и/или блокировать submit формы
2. проверять валидность email после отправки на стороне сервера
    - laravel: использовать стандартный валидатор email
        - в Request
        ```$php
        public function rules()
        {
            return [
                'email' => 'required|email',
            ];
        }
        ```
    - Yii2: использовать стандартный валидатор email
        - в модели
        ```$php
        public function rules()
        {
            return [
                // обязательно для заполнения
                [['email'], 'required'],
        
                // в переменной email должен быть корректный адрес электронной почты
                ['email', 'email'],
            ];
        }
        ```
        - либо валидацией отдельного поля
        ```$php
        $email = 'test@test.ru';
        $validator = new yii\validators\EmailValidator();
        
        if ($validator->validate($email, $error)) {
            echo 'Email is valid.';
        } else {
            echo $error;
        }
        ```
        
Лучше проверять как на стороне клиента, так и на стороне сервера.

> 2.1 Используя Yii2 необходимо реализовать форму регистрации пользователя с условием типа физ./юр. лицо. Для физ. лица необходимо заполнить: почту, ФИО и в случае ИП - ИНН, а для юр. лица: почту, ФИО, название организации и инн. Внешний вид значения не имеет.

Сделал через две модели:
- RegisterForm.php - регистрация физ.лица
- RegisterLegalForm.php - регистрация юр.лица

Также можно было сделать одной формой с использованием сценариев.

Код смотреть здесь: [test app](https://github.com/golovchanskiy/SkyengTest/test)

> 2.2 Реализовать кеширование для функции

Вариант 1. Использовать кешиноварие запросов

```$php
function($date, $type) {
    $userId = Yii::$app->user->id;
    
    $dataList = SomeDataModel::getDb()->cache(function ($db) {
        return SomeDataModel::find()
            ->where(['date' => $date, 'type' => $type, 'user_id' => $userId])
            ->all();
    });

    $result = [];
 
    if (!empty($dataList)) {
        foreach ($dataList as $dataItem) {
        	$result[$dataItem->id] = ['a' => $dataItem->a, 'b' => $dataItem->b];
        }
    }
 
    return $result;
}
```

Вариант 2. Кешировать нужные данные

```$php
function($date, $type) {
    $userId = Yii::$app->user->id;
    
    // имя кеша
    $cacheName = 'some_data_u' . $userId . '_d' . $date . '_t' . $type;
    
    // получаем данные из кеша
    $result = Yii::$app->cache->get($cacheName);
    
    // если данных в кеше нет, то получаем из БД и добавляем в кеш
    if(!$result){
        $dataList = SomeDataModel::find()
                ->where([
                'date' => $date, 
                'type' => $type, 
                'user_id' => $userId
            ])->all();
        $result = [];
     
        if (!empty($dataList)) {
            foreach ($dataList as $dataItem) {
                $result[$dataItem->id] = ['a' => $dataItem->a, 'b' => $dataItem->b];
            }
        }
        
        Yii::$app->cache->set($cacheName, $result, 3600);
    }
 
    return $result;
}
```

> 2.3 Схематично описать структуру таблиц для хранения информации о медикаментах со следующими требованиями: лекарство имеет название, срок годности и список болезней, при которых это лекарство можно применять.

Вариант 1.
- таблица медикаментов: drug
    - drug_id - ID
    - name - Название
    - expiry_days - Срок годности, дни
- таблица болезней: disease
    - disease_id - ID
    - name - Название
- таблица связией медикаментов и заболеваний: drug_to_disease
    - drug_id - ID медикамента
    - disease_id - ID болезни
    
При использовании данного варианта добавление новых свойств происходит добавлением полей в таблицу drug, либо добавление новых таблиц и таблиц связей.

Вариант 2.
- таблица медикаментов: drug
    - drug_id - ID
    - name - Название
- таблица свойств: property
    - property_id
    - name
    - is_multiple - Множественный выбор
- таблица значений свойств: value
    - value_id
    - property_id
    - data
- таблица связи медикаментов со значениями свойств: drug_to_value
    - drug_id
    - property_id
    - value_id

Создаем нужные свойства срок годности и болезнь + значения для них.

При использовании данного варианта можем легко добавлять новые свойства и значения медикаментов.

Также можно расширить типом свойств (property_type):
- целое
- дробное
- логическое
- строка
- текст

При этом для каждого типа свойств можно указать в БД валидатор.
